package cli

import (
	"encoding/csv"
	"fmt"
	"go/format"
	"maps"
	"slices"
	"strings"
	"time"
)

// These functions must be in a separate package from the [latency] package because
// if a change in these functions causes the generated code in the [latency] package
// to be non-compilable, the latencygen tool would not be able to compile these functions.

// ParseCSVLatencies reads a CSV string and returns a map of maps representing the latency matrix.
func ParseCSVLatencies(csvData string) (map[string]map[string]string, error) {
	reader := csv.NewReader(strings.NewReader(csvData))
	rows, err := reader.ReadAll()
	if err != nil {
		return nil, fmt.Errorf("failed to read CSV data: %w", err)
	}
	if len(rows) < 2 {
		return nil, fmt.Errorf("incomplete CSV data")
	}
	// Extract city names from the first row
	cities := rows[0][1:] // Skip the first column as it's the row headers
	if len(cities) == 0 {
		return nil, fmt.Errorf("no cities found in the header row")
	}

	allToAllMatrix := make(map[string]map[string]string, len(cities))
	for _, row := range rows[1:] { // Skip the header row
		if len(row) < 2 {
			continue // Skip empty or malformed rows
		}
		// First column is the city name for this row
		rowCity := row[0]
		if allToAllMatrix[rowCity] == nil {
			allToAllMatrix[rowCity] = make(map[string]string, len(cities))
		}
		// Populate the matrix for this row
		for i, latency := range row[1:] {
			colCity := cities[i]
			allToAllMatrix[rowCity][colCity] = latency
		}
	}
	return allToAllMatrix, nil
}

// GenerateGoLatencyMatrix generates Go code for the latency matrix so that it can be compiled into the binary.
func GenerateGoLatencyMatrix(srcFile string, allToAllMatrix map[string]map[string]string) ([]byte, error) {
	keys := slices.Sorted(maps.Keys(allToAllMatrix))

	s := strings.Builder{}
	s.WriteString(`// Code generated by latencygen. DO NOT EDIT.
// source: `)
	s.WriteString(srcFile)
	s.WriteString(`
package latency

import "time"

// SourceFile is the CSV file used to generate this latency matrix.
const SourceFile = `)
	s.WriteString(`"` + srcFile + `"`)
	s.WriteString(`

var allLocations = []string{`)
	var longestCityName int
	// Write the location names to the `allLocations` slice
	for _, locationName := range keys {
		if len(locationName) > longestCityName {
			longestCityName = len(locationName)
		}
		s.WriteString(fmt.Sprintf("%q, ", locationName))
	}
	s.WriteString("}\n\n")

	// Write the 2D latency slice
	s.WriteString("// All one-way latencies between locations.\n")
	s.WriteString("var allLatencies = [][]time.Duration{\n")
	for idx, locationName := range keys {
		paddedCity := fmt.Sprintf("%-*s", longestCityName, locationName)
		s.WriteString(fmt.Sprintf("\t/* %03d: %s */ {", idx, paddedCity))
		latencyVector := allToAllMatrix[locationName]
		for _, locationName2 := range keys {
			// Parse the latency as time.Duration
			latency, err := time.ParseDuration(latencyVector[locationName2] + "ms")
			if err != nil {
				return nil, fmt.Errorf("invalid latency between %s and %s: %w", locationName, locationName2, err)
			}
			// Divide the round-trip latency by 2 to simulate one-way latency
			s.WriteString(fmt.Sprintf("%d, ", latency/2))
		}
		s.WriteString("},\n")
	}
	s.WriteString("}\n")

	latenciesGoCode, err := format.Source([]byte(s.String()))
	if err != nil {
		return nil, fmt.Errorf("failed to format Go code: %w", err)
	}
	return latenciesGoCode, nil
}

// LatencyMatrix returns the location names and the full latency matrix.
// Currently not used, but it could be used if we want to load latency data at runtime.
func LatencyMatrix(allToAllMatrix map[string]map[string]string) ([]string, [][]time.Duration) {
	keys := slices.Sorted(maps.Keys(allToAllMatrix))
	allLatencies := make([][]time.Duration, len(keys))
	for i, locationName := range keys {
		latencyVector := allToAllMatrix[locationName]
		allLatencies[i] = make([]time.Duration, len(keys))
		for j, locationName2 := range keys {
			// Parse the latency as time.Duration
			latency, err := time.ParseDuration(latencyVector[locationName2] + "ms")
			if err != nil {
				panic(fmt.Errorf("invalid latency between %s and %s: %w", locationName, locationName2, err))
			}
			// Divide the round-trip latency by 2 to simulate one-way latency
			allLatencies[i][j] = latency / 2
		}
	}
	return keys, allLatencies
}
